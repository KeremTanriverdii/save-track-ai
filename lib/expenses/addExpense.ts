import { differenceInMonths } from "date-fns";
import { collection, doc, increment, serverTimestamp, Timestamp, writeBatch } from "firebase/firestore";
import { ExpensePayload } from "../types/type";
import { db } from "../firebase/firebase";
import { dateCustom } from "@/utils/nowDate";
import { getBudget } from "../budged/GetBudget";

export const addExpense = async (userSend: ExpensePayload, userId: string) => {
    const batch = writeBatch(db);
    const expensesCollectionRef = collection(db, 'users', userId, 'expenses');
    const selectedDate = userSend.expenseDate ? new Date(userSend.expenseDate) : new Date();
    const date = dateCustom();
    const budget = await getBudget(userId, date) as { budget: number, currency: string };

    const finalData: any = {
        amount: userSend.amount,
        category: Array.isArray(userSend.category) ? userSend.category : [userSend.category],
        title: userSend.title || "",
        description: userSend.description || "",
        date: Timestamp.fromDate(selectedDate),
        createdAt: serverTimestamp(),
        currency: budget?.currency || "USD",
        type: userSend.type || 'one-time'
    };


    let amountToAddToTotal = 0;
    let cyclesToIncrement = 0;

    if (userSend.type === 'subscription' && userSend.subscription) {
        finalData.subscriptionDetails = {
            frequency: userSend.subscription.frequency,
            startDate: Timestamp.fromDate(new Date(userSend.subscription.startDate)),
            status: userSend.subscription.status || "active",
            billingDay: Number(userSend.subscription.billingDay),
            billingMonth: Number(userSend.subscription.billingMonth)
        };
    }


    if (userSend.type === 'subscription' && userSend.subscription?.startDate) {
        const start = new Date(userSend.subscription.startDate);
        const now = new Date();

        if (start < now) {
            let cyclesPassed = 0;
            if (userSend.subscription.frequency === 'monthly') {
                cyclesPassed = differenceInMonths(now, start);
            } else if (userSend.subscription.frequency === 'yearly') {
                cyclesPassed = Math.floor(differenceInMonths(now, start) / 12);
            }

            cyclesToIncrement = Math.max(0, cyclesPassed) + 1;
            amountToAddToTotal = cyclesToIncrement * userSend.amount

            for (let i = 0; i < cyclesToIncrement; i++) {
                const transactionDate = new Date(start);
                transactionDate.setMonth(transactionDate.getMonth() + i);

                const monthlyExpenseRef = doc(expensesCollectionRef);
                batch.set(monthlyExpenseRef, {
                    ...finalData,
                    date: Timestamp.fromDate(transactionDate),
                    numberOfMonthsPaid: i + 1,
                    isAutoGenerated: true,
                });
            }
        }
    } else {
        amountToAddToTotal = userSend.amount;
        cyclesToIncrement = 0;

        const expenseDocRef = doc(expensesCollectionRef);
        batch.set(expenseDocRef, finalData);
    }

    const userRef = doc(db, 'users', userId);

    const updateField = userSend.type === 'subscription'
        ? 'totalSubscriptionSpent'
        : 'totalOneTimeSpent';

    batch.update(userRef, {
        totalSpent: increment(amountToAddToTotal),
        [updateField]: increment(amountToAddToTotal),
        lastUpdated: serverTimestamp()
    });

    if (!userSend.title) return 'title';

    const subRef = doc(userRef, 'subscriptionsDetails', userSend.title);
    batch.set(subRef, {
        totalPaidForThis: increment(amountToAddToTotal),
        monthlyCost: userSend.amount,
        accumulatedTotal: increment(amountToAddToTotal),
        status: userSend.subscription?.status || 'active',
        lastUpdated: serverTimestamp(),
        category: userSend.category,
        totalPeriodsProcessed: increment(cyclesToIncrement),
        currency: budget?.currency || 'USD',
        frequency: userSend.subscription?.frequency || 'error'
    }, { merge: true });

    await batch.commit();
    return "Success";
}