import { differenceInMonths } from "date-fns";
import { ExpensePayload } from "../types/type";
import { dateCustom } from "@/utils/nowDate";
import { getBudget } from "../budged/GetBudget";
import admin from "../firebase/admin";
import { Timestamp, FieldValue } from "firebase-admin/firestore";

export const addExpense = async (userSend: ExpensePayload, userId: string) => {
    const db = admin.firestore();
    const batch = db.batch();
    const userRef = db.collection('users').doc(userId)
    const expensesCollectionRef = db.collection('users').doc(userId).collection('expenses');
    const selectedDate = userSend.expenseDate ? new Date(userSend.expenseDate) : new Date();
    const date = dateCustom();
    const budget = await getBudget(userId, date) as { budget: number, currency: string };

    let subscriptionId: string | null = null;
    let subRef: admin.firestore.DocumentReference | null = null;

    if (userSend.type === 'subscription') {
        const newSubDoc = userRef.collection('subscriptionDetails').doc();
        subRef = newSubDoc;
        subscriptionId = newSubDoc.id
    }

    const finalData: any = {
        amount: userSend.amount,
        category: Array.isArray(userSend.category) ? userSend.category : [userSend.category],
        title: userSend.title || "",
        description: userSend.description || "",
        date: Timestamp.fromDate(selectedDate),
        createdAt: Timestamp.now(),
        currency: budget?.currency,
        type: userSend.type || 'one-time'
    };

    let amountToAddToTotal = 0;
    let cyclesToIncrement = 0;



    if (userSend.type === 'subscription' && userSend.subscription) {
        if (!userSend.title) return 'title';

        const start = new Date(userSend.subscription.startDate);
        const now = new Date();

        finalData.subscriptionDetails = {
            frequency: userSend.subscription.frequency,
            startDate: Timestamp.fromDate(start),
            status: userSend.subscription.status || "active",
            billingDay: Number(userSend.subscription.billingDay),
            billingMonth: Number(userSend.subscription.billingMonth)
        };

        if (start <= now) {
            let cyclesPassed = 0;
            if (userSend.subscription.frequency === 'monthly') {
                cyclesPassed = differenceInMonths(now, start);
            } else if (userSend.subscription.frequency === 'yearly') {
                cyclesPassed = Math.floor(differenceInMonths(now, start) / 12);
            }

            cyclesToIncrement = Math.max(0, cyclesPassed) + 1;
            amountToAddToTotal = cyclesToIncrement * userSend.amount;

            for (let i = 0; i < cyclesToIncrement; i++) {
                const transactionDate = new Date(start);
                transactionDate.setMonth(transactionDate.getMonth() + i);

                const monthlyExpenseRef = expensesCollectionRef.doc();
                batch.set(monthlyExpenseRef, {
                    ...finalData,
                    subscriptionId,
                    date: Timestamp.fromDate(transactionDate),
                    numberOfMonthsPaid: i + 1,
                    isAutoGenerated: true,
                });
            }
        } else {
            amountToAddToTotal = 0;
            cyclesToIncrement = 0;
            const expenseDocRef = expensesCollectionRef.doc();
            batch.set(expenseDocRef, { finalData, subscriptionId });
        }

        const subRef = db.collection('users').doc(userId).collection('subscriptionDetails').doc(subscriptionId!);
        batch.set(subRef, {
            id: subscriptionId,
            title: userSend.title,
            totalPaidForThis: FieldValue.increment(amountToAddToTotal),
            monthlyCost: userSend.amount,
            accumulatedTotal: FieldValue.increment(amountToAddToTotal),
            status: userSend.subscription?.status || 'active',
            lastUpdated: Timestamp.now(),
            category: userSend.category,
            totalPeriodsProcessed: FieldValue.increment(cyclesToIncrement),
            currency: budget?.currency,
            frequency: userSend.subscription?.frequency || 'error'
        }, { merge: true });

    } else {
        amountToAddToTotal = userSend.amount;
        cyclesToIncrement = 0;
        const expenseDocRef = expensesCollectionRef.doc();
        batch.set(expenseDocRef, finalData);
    }

    const updateField = userSend.type === 'subscription'
        ? 'totalSubscriptionSpent'
        : 'totalOneTimeSpent';

    batch.update(userRef, {
        totalSpent: FieldValue.increment(amountToAddToTotal),
        [updateField]: FieldValue.increment(amountToAddToTotal),
        lastUpdated: Timestamp.now()
    });


    try {
        batch.commit();
        return 'Success'
    } catch (err) {
        console.error('eeror adding expense', err)
        return 'Error adding expense'
    }
}